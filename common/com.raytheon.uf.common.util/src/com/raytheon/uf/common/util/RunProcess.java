/**
 * This software was developed and / or modified by Raytheon Company,
 * pursuant to Contract DG133W-05-CQ-1067 with the US Government.
 * 
 * U.S. EXPORT CONTROLLED TECHNICAL DATA
 * This software product contains export-restricted data whose
 * export/transfer/disclosure is restricted by U.S. law. Dissemination
 * to non-U.S. persons whether in the United States or abroad requires
 * an export license or other authorization.
 * 
 * Contractor Name:        Raytheon Company
 * Contractor Address:     6825 Pine Street, Suite 340
 *                         Mail Stop B8
 *                         Omaha, NE 68106
 *                         402.291.0100
 * 
 * See the AWIPS II Master Rights File ("Master Rights File.pdf") for
 * further licensing information.
 **/
package com.raytheon.uf.common.util;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;

/**
 * This class is intended to work as a wrapper class around a Process generated
 * by ProcessBuilder or Runtime. It prevents locking caused by filling the
 * stderr or stdout buffers and properly cleans up the process when it
 * terminates. Intended use is for a process generated by the command: <li>
 * Runtime.getRuntime().exec(...)</li> <li><b>instead do:</b></li> <li>
 * RunProcess.getRunProcess().exec(...);</li> <li><b>or</b></li> <li>
 * RunProcess.getRunProcess.setProcess(ProcessBuilder.start())</li>
 * 
 * <pre>
 * 
 * SOFTWARE HISTORY
 * 
 * Date         Ticket#    Engineer    Description
 * ------------ ---------- ----------- --------------------------
 * Sep 19, 2011 10955      rferrel     Initial creation
 * 
 * </pre>
 * 
 * @author rferrel
 * @version 1.0
 */
public class RunProcess {
    /**
     * Exit value returned when Process interrupted.
     */
    public static final int INTERRUPTED = -99;

    /**
     * Exit value set to this value prior to waiting for the process to finish.
     */
    public static final int UNKNOWN = -100;

    /**
     * The process being monitored.
     */
    private Process process;

    private boolean execComplete;

    private int exitValue;

    private boolean processInterrupted = false;

    private StringBuilder fromStdout;

    private StringBuilder fromStderr;

    /**
     * Method for getting a RunProcess.
     */
    public static RunProcess getRunProcess() {
        return new RunProcess();
    }

    private RunProcess() {
        this.execComplete = false;
        fromStdout = new StringBuilder();
        fromStderr = new StringBuilder();
    }

    private void startThreads() {
        Thread thread = new Thread(new Runnable() {

            @Override
            public void run() {
                read(fromStdout, process.getInputStream());
            }
        });
        thread.start();

        thread = new Thread(new Runnable() {

            @Override
            public void run() {
                read(fromStderr, process.getErrorStream());
            }
        });
        thread.start();

        thread = new Thread(new Runnable() {

            @Override
            public void run() {
                try {
                    exitValue = UNKNOWN;
                    exitValue = process.waitFor();
                } catch (InterruptedException e) {
                    processInterrupted = true;
                    exitValue = INTERRUPTED;
                } finally {
                    setComplete();
                    process.destroy();
                }
            }
        });
        thread.start();
    }

    private void read(StringBuilder sb, InputStream stream) {
        BufferedReader br = new BufferedReader(new InputStreamReader(stream));
        String line;
        try {
            while ((line = br.readLine()) != null) {
                sb.append(line).append("\n");
            }
            br.close();
        } catch (IOException ex) {
            // Ignore steam already closed or redirected?
            // System.err.println("read error: " + ex.getMessage());
        }
    }

    private synchronized void setComplete() {
        execComplete = true;
        notify();
    }

    /**
     * This method should be called only after the waitFor() returns. It is a
     * check just in case a process finish normally and happens to return the
     * INTERRUPTED value.
     * 
     * @return true when process interrupted otherwise false
     */
    public boolean isProcessInterrupted() {
        return processInterrupted;
    }

    /**
     * Convince method that calls the Runtime exec command to set the process.
     * 
     * @param command
     * @return this
     * @throws IOException
     */
    public RunProcess exec(String command) throws IOException {
        setProcess(Runtime.getRuntime().exec(command));
        return this;
    }

    /**
     * Convince method that calls the Runtime exec command to set the process.
     * 
     * @param cmdarray
     * @return this
     * @throws IOException
     */
    public RunProcess exec(String[] cmdarray) throws IOException {
        setProcess(Runtime.getRuntime().exec(cmdarray));
        return this;
    }

    /**
     * Convince method that calls the Runtime exec command to set the process.
     * 
     * @param cmdarray
     * @param envp
     * @return this
     * @throws IOException
     */
    public RunProcess exec(String[] cmdarray, String[] envp) throws IOException {
        setProcess(Runtime.getRuntime().exec(cmdarray, envp));
        return this;
    }

    /**
     * Convince method that calls the Runtime exec command to set the process.
     * 
     * @param cmdarray
     * @param envp
     * @param dir
     * @return this
     * @throws IOException
     */
    public RunProcess exec(String[] cmdarray, String[] envp, File dir)
            throws IOException {
        setProcess(Runtime.getRuntime().exec(cmdarray, envp, dir));
        return this;
    }

    /**
     * Convince method that calls the Runtime exec command to set the process.
     * 
     * @param command
     * @param envp
     * @return this
     * @throws IOException
     */
    public RunProcess exec(String command, String[] envp) throws IOException {
        setProcess(Runtime.getRuntime().exec(command, envp));
        return this;
    }

    /**
     * Convince method that calls the Runtime exec command to set the process.
     * 
     * @param command
     * @param envp
     * @param dir
     * @return this
     * @throws IOException
     */
    public RunProcess exec(String command, String[] envp, File dir)
            throws IOException {
        setProcess(Runtime.getRuntime().exec(command, envp, dir));
        return this;
    }

    /**
     * This sets the process the instance is a wrapper class for; and starts the
     * thread for getting stdout, stderr and monitoring for the completion of
     * the process.
     * 
     * @param process
     */
    public void setProcess(Process process) {
        this.process = process;
        startThreads();
    }

    // /**
    // * Do not use. Instead use the waitFor method. The process.exitValue
    // throws
    // * an exception when process is not completed.
    // */
    // public void exitValue() {
    // // Does nothing.
    // // return process.exitValue();
    // }

    /**
     * Wait for the process to finish.
     * 
     * @return exitValue or INTERRUPT when interrupted
     * @throws IllegalThreadStateException
     *             when no process
     */
    public synchronized int waitFor() {
        if (process == null) {
            throw new IllegalThreadStateException("No process");
        }
        if (execComplete == false) {
            try {
                wait();
            } catch (InterruptedException ex) {
                processInterrupted = true;
                execComplete = true;
                exitValue = INTERRUPTED;
            }
        }

        // In case more then one thread is doing a waitFor.
        notify();
        return exitValue;
    }

    /**
     * Indicates execution status of the process.
     * 
     * @return true when process completed or interrupted otherwise false
     */
    public boolean isExecComplete() {
        return execComplete;
    }

    /**
     * This waits for the process to complete then returns everything sent to
     * stdout.
     * 
     * @return stdout
     * @throws IllegalThreadStateException
     *             when no process
     */
    public String getStdout() {
        waitFor();
        return fromStdout.toString();
    }

    /**
     * This waits for the process to complete then returns everything sent to
     * stderr.
     * 
     * @return stderr
     * @throws IllegalThreadStateException
     *             when no process
     */
    public String getStderr() {
        waitFor();
        return fromStderr.toString();
    }

    // public static void main(String[] args) {
    // try {
    // RunProcess rp = RunProcess.getRunProcess().exec(
    // "/bin/cat /home/rferrel/.bashrc /home/rferrel/.cshrc");
    // rp.waitFor();
    // System.out.println("<stdout>");
    // System.out.print(rp.getStdout());
    // System.out.println("</stdout>");
    // System.out.flush();
    // System.err.println("\n<stderr>");
    // System.err.print(rp.getStderr());
    // System.err.println("</stderr>");
    //
    // System.out.println("\n\n+++ Using Process builder +++\n");
    // ProcessBuilder pb = new ProcessBuilder("/bin/cat", ".cshrc",
    // ".bashrc", ".cshrc");
    // pb.directory(new File("/home/rferrel"));
    // pb.redirectErrorStream(true);
    // rp = RunProcess.getRunProcess();
    // rp.setProcess(pb.start());
    // rp.waitFor();
    // System.out.println("<stdout>");
    // System.out.print(rp.getStdout());
    // System.out.println("</stdout>");
    // System.out.flush();
    // System.err.println("\n<stderr>");
    // System.err.print(rp.getStderr());
    // System.err.println("</stderr>");
    //
    // } catch (Exception ex) {
    // ex.printStackTrace();
    // }
    // System.exit(0);
    // }
}
